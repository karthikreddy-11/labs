
10. First fit, Best Fit, Worst fit
#include<stdio.h>
#include<conio.h>
void main()
{
int f3[20],f2[20],r[20],r1[20],ms,bod,sb[20],nsb[20],nsb1[20],np,sp[20];
int f[20],i,j,l,k,z[20],s=0;
clrscr();
printf("enter the memory size:");
scanf("%d",&ms);
printf("\n enter the number of block of division of memory:");
scanf("%d",&bod);
printf("enter the size of each block:");
for(i=1;i<=bod;i++)
{
printf("\nBlock[%d]:",i);
scanf("%d",&sb[i]);
f[i]=1;
f2[i]=1;
f3[i]=1;
r[i]=1;
r1[i]=1;
z[i]=sb[i];
}
printf("\nenter the number of process:");
scanf("%d",&np);
printf("\nenter the size of each process:");
for(i=1;i<=np;i++)
{
printf("\nprocess[%d]:",i);
scanf("%d",&sp[i]);
}
printf("\n FIRST FIT ");
printf("\n ********* ");
for(i=1;i<=np;i++)
{
for(j=1;j<=bod;j++)
{
if((sb[j]>=sb[i]) && (f[j]!=0))
{
printf("\n Process p[%d] is allocated to Block[%d]",i,j);
f[j]=0;
z[j]=sb[j]-sp[i];
s++;
goto l1;
}
}
printf("\n process p[%d] cannot be allocated",i);
l1:
printf(" ");
}
printf("\n\n Remaining space left in each block \n");
printf("\n ********************************** \n");
for(i=1;i<=bod;i++)
{
printf("\n Block[%d]: free space =%d",i,z[i]);
}
printf("\n\nUnallocated Blocks");
printf(" \n ******************");
for(i=1;i<=bod;i++)
{
if(f[i]!=0)
{
printf("\n Block [%d] unallocated",i);
}
}
if(s==bod)
printf("\n No Block is left unallocated");
getch();
clrscr();
s=0;
getch();
printf("\n\n BEST FIT ");
printf("\n ******** ");
for(i=2;i<=bod;i++)
{
for(j=1;j<i;j++)
{
if(sb[i]>=sb[j])
r[i]++;
else
r[j]++;
}
}
for(i=1;i<=bod;i++)
{
nsb[r[i]]=sb[i];
z[r[i]]=sb[i];
}
for(i=1;i<=np;i++)
{
for(j=1;j<=bod;j++)
{
if((nsb[j]>=sp[i]) && (f2[j]!=0))
{
for(k=1;k<=bod;k++)
{
if(r[k]==j)
l=k;
}
printf("\nProcess p[%d] is allocated to Block[%d]",i,l);
f2[j]=0;
z[j]=nsb[j]-sp[i];
s++;
goto l2;
}
}
printf("\n process p[%d] cannot be allocated",i);
l2:
printf(" ");
}
printf("\n free space in each block \n");
printf(" ************************ \n");
for(i=1;i<=bod;i++)
printf("\nBlock [%d]: free space =%d",i,z[r[i]]);
printf("\n\nUnallocated Blocks");
printf(" \n ******************");
for(i=1;i<=bod;i++)
{
if(f2[r[i]]!=0)
{
printf("\n Block [%d] unallocated",i);
}
}
if(s==bod)
printf("\n No Block is left unallocated");
getch();
clrscr();
s=0;
getch();
printf("\n\n WORST FIT ");
printf("\n ********* ");
for(i=2;i<=bod;i++)
{
for(j=1;j<i;j++)
{
if(sb[i]<=sb[j])
r1[i]++;
else
r1[j]++;
}
}
for(i=1;i<=bod;i++)
{
nsb1[r1[i]]=sb[i];
z[r1[i]]=sb[i];
}
for(i=1;i<=np;i++)
{
for(j=1;j<=bod;j++)
{
if((nsb1[j]>=sp[i]) && (f3[j]!=0))
{
for(k=1;k<=bod;k++)
{
if(r1[k]==j)
l=k;
}
printf("\nProcess p[%d] is allocated to Block[%d]",i,l);
f3[j]=0;
z[j]=nsb1[j]-sp[i];
s++;
goto l3;
}
}
printf("\n process p[%d] cannot be allocated",i);
l3:
printf(" ");
}
printf("\n free space in each block \n");
printf(" ************************ \n");
for(i=1;i<=bod;i++)
printf("\nBlock [%d]: free space =%d",i,z[r1[i]]);
printf("\n\nUnallocated Blocks");
printf(" \n ******************");
for(i=1;i<=bod;i++)
{
if(f3[r1[i]]!=0)
{
printf("\n Block [%d] unallocated",i);
}
if(s==bod)
printf("\n No Block is left unallocated");
getch();
printf("\n");
}
}
11. Bankers Algorithm
#include<stdio.h>
#include<conio.h>
int np,nr,r[10],safe[10],ava[10],aval[10],re[10],f[10],i,j,flag,z,index,pid;
int m[10][10],need[10][10],all[10][10];
void resourse()
{
printf("\nEnter the no. of resourses: ");
scanf("%d",&nr);
printf("\nEnter the resources instances \n");
for(i=0;i<nr;i++)
scanf("%d",&r[i]);
}
void alloc()
{
printf("\nEnter the no of process: ");
scanf("%d",&np);
for(i=0;i<np;i++)
{
f[i]=0;
for(j=0;j<nr;j++)
{
printf("\n Resourse %d for %d ",j+1,i+1);
scanf("%d",&all[i][j]);
}}}
void maxreq()
{
printf("\nEnter the maximum request for each process \n");
for(i=0;i<np;i++)
for(j=0;j<nr;j++)
scanf("%d",&m[i][j]);
printf("\nThe Available Matrix\n");
printf("----------------------\n");
for(i=0;i<nr;i++)
{
z=0;
for(j=0;j<np;j++)
z+=all[j][i];
ava[i]=r[i]-z;
printf("%d\t",ava[i]);
aval[i]=ava[i];
}}
void needcal()
{
printf("\n");
printf("\nThe Need Matrix \n");
printf("-------------------\n");
for(i=0;i<np;i++)
{
printf("\n");
for(j=0;j<nr;j++)
{
need[i][j]=m[i][j]-all[i][j];
printf("%d\t",need[i][j]);
}}
printf("\n\n");
}
void request()
{
flag=0;index=0;
printf("\nEnter the requesting process id:");
scanf("%d",&pid);
printf("\nEnter the resourseintance required \n");
for(i=0;i<nr;i++)
{
scanf("%d",&re[i]);
if(re[i]>m[pid][i]);
flag=1;
}
if(flag==0)
{
for(i=0;i<nr;i++)
need[pid][i]=re[i];
for(i=0;i<np;i++)
{
printf("\n");
for(j=0;j<nr;j++)
printf("%d \t",need[i][j]);
}}
else
{
printf("\n request exceeds maximum request");
exit(0);
}.
}
void out()
{
printf("The safe sequensce is\n");
for(i=0;i<np;i++)
printf("p[%d]\t",safe[i]);
printf("\n\n");
}
void safety()
{
flag=0;i=0;j=0;z=0;index=0;
while(1)
{
if(z++ > 2*np)
{
printf("\n no safe sequence");
exit(0);
}
for(j=0;j<nr;j++)
{
if(need[i][j] <=ava[j]&&f[i] !=1)
{
flag=0;
}
else
{
flag=1;
break;
}
}
if(flag==0)
{
f[i]=1;
safe[index]=i;
for(j=0;j<nr;j++)
ava[j]+= all[i][j];
index++;
if(index >=np)
return;
}
i++;
if(i>=np)
i=0;
}
}
void main()
{
clrscr();
resourse();
alloc();
maxreq();
needcal();
safety();
out();
for(i=0;i<np;i++)
{f[i]=0;safe[i]=0;}
request();
for(j=0;j<nr;j++)
ava[j]=aval[j];
safety();
out();
}
12. Producer Consumer Problem
#include<stdio.h>
#include<conio.h>
int main()
{
int s,n,b=0,p=0,c=0;
clrscr();
printf("\n producer and consumer problem");
do
{
printf("\n menu");
printf("\n 1.producer an item");
printf("\n 2.consumer an item");
printf("\n 3.add item to the buffer");
printf("\n 4.display status");
printf("\n 5.exit");
printf("\n enter the choice");
scanf("%d",&s);
switch(s)
{
case 1:
p=p+1;
printf("\n item to be produced");
break;
case 2:
if(b!=0)
{
c=c+1;
b=b-1;
printf("\n item to be consumed");
}
else
{
printf("\n the buffer is empty please wait...");
}
break;
case 3:
if(b<n)
{
if(p!=0)
{
b=b+1;
printf("\n item added to buffer");
}
else
printf("\n no.of items to add...");
}
else
printf("\n buffer is full,please wait");
break;
case 4:
printf("no.of items produced :%d",p);
printf("\n no.of consumed items:%d",c);
printf("\n no.of buffered item:%d",b);
break;
case 5:exit(0);
}
}
while(s<=5);
getch();
return 0;
}
